{"ast":null,"code":"/* jshint node: true */\n\"use strict\";\n\nvar lib = {};\nvar nextTick = process.nextTick || global.setImmediate || global.setTimeout;\n\nlib.nextTick = function (func) {\n  nextTick(func);\n};\n\nlib.parallel = function (tasks, done) {\n  var results = [];\n  var errs = [];\n  var length = 0;\n  var doneLength = 0;\n\n  function doneIt(ix, err, result) {\n    if (err) {\n      errs[ix] = err;\n    } else {\n      results[ix] = result;\n    }\n\n    doneLength += 1;\n\n    if (doneLength >= length) {\n      done(errs.length > 0 ? errs : errs, results);\n    }\n  }\n\n  Object.keys(tasks).forEach(function (key) {\n    length += 1;\n    var task = tasks[key];\n    lib.nextTick(function () {\n      task(doneIt.bind(null, key), 1);\n    });\n  });\n};\n\nlib.promisify = function (func) {\n  return new Promise(function (resolve, reject) {\n    func(function (err, data) {\n      if (err) {\n        if (!err instanceof Error) {\n          err = new Error(err);\n        }\n\n        reject(err);\n        return;\n      }\n\n      resolve(data);\n    });\n  });\n};\n\nlib.iterate = function (args, func, callback) {\n  var errors = [];\n\n  var f = function f() {\n    if (args.length === 0) {\n      lib.nextTick(callback.bind(null, errors));\n      return;\n    }\n\n    var arg = args.shift();\n\n    if (typeof arg === \"function\") {\n      arg(function (err, res) {\n        if (err) {\n          errors.push(err);\n        } else {\n          while (res.length > 0) {\n            args.unshift(res.pop());\n          }\n        }\n\n        f();\n      });\n      return;\n    }\n\n    func(arg, function (err, res) {\n      if (err) {\n        errors.push(err);\n        f();\n      } else {\n        lib.nextTick(callback.bind(null, null, res));\n      }\n    });\n  };\n\n  lib.nextTick(f);\n};\n\nmodule.exports = lib;","map":null,"metadata":{},"sourceType":"script"}