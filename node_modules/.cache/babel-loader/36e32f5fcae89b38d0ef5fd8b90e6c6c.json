{"ast":null,"code":"/* jshint node: true */\n\"use strict\";\n\nvar util = require(\"./lib/util.js\");\n\nvar lib = {};\nlib.getMacAddress = require(\"./lib/getmacaddress.js\");\nlib.getAllInterfaces = require(\"./lib/getallinterfaces.js\");\nlib.networkInterfaces = require(\"./lib/networkinterfaces.js\"); // devices like en0 (mac), eth3 (linux), Ethernet (windows), etc. are preferred\n\nvar goodIfaces = new RegExp(\"^((en|eth)[0-9]+|ethernet)$\", \"i\"); // https://github.com/scravy/node-macaddress/issues/32\n\nvar badIfaces = new RegExp(\"^(vboxnet[0-9]+)$\", \"i\");\n\nlib.one = function () {\n  // one() can be invoked in several ways:\n  // one() -> Promise<string>\n  // one(iface: string) -> Promise<string>\n  // one(iface: string, callback) -> async, yields a string\n  // one(callback) -> async, yields a string\n  var iface = null;\n  var callback = null;\n\n  if (arguments.length >= 1) {\n    if (typeof arguments[0] === \"function\") {\n      callback = arguments[0];\n    } else if (typeof arguments[0] === \"string\") {\n      iface = arguments[0];\n    }\n\n    if (arguments.length >= 2) {\n      if (typeof arguments[1] === \"function\") {\n        callback = arguments[1];\n      }\n    }\n  }\n\n  if (!callback) {\n    return util.promisify(function (callback) {\n      lib.one(iface, callback);\n    });\n  }\n\n  if (iface) {\n    lib.getMacAddress(iface, callback);\n    return;\n  }\n\n  var ifaces = lib.networkInterfaces();\n  var addresses = {};\n  var best = [];\n  var args = [];\n  Object.keys(ifaces).forEach(function (name) {\n    args.push(name);\n    var score = 0;\n    var iface = ifaces[name];\n\n    if (typeof iface.mac === \"string\" && iface.mac !== \"00:00:00:00:00:00\") {\n      addresses[name] = iface.mac;\n\n      if (iface.ipv4) {\n        score += 1;\n      }\n\n      if (iface.ipv6) {\n        score += 1;\n      }\n\n      if (goodIfaces.test(name)) {\n        score += 2;\n      }\n\n      if (badIfaces.test(name)) {\n        score -= 3;\n      }\n\n      best.push({\n        name: name,\n        score: score,\n        mac: iface.mac\n      });\n    }\n  });\n\n  if (best.length > 0) {\n    best.sort(function (left, right) {\n      // the following will sort items with a higher score to the beginning\n      var comparison = right.score - left.score;\n\n      if (comparison !== 0) {\n        return comparison;\n      }\n\n      if (left.name < right.name) {\n        return -1;\n      }\n\n      if (left.name > right.name) {\n        return 1;\n      }\n\n      return 0;\n    });\n    util.nextTick(callback.bind(null, null, best[0].mac));\n    return;\n  }\n\n  args.push(lib.getAllInterfaces);\n\n  var getMacAddress = function getMacAddress(d, cb) {\n    if (addresses[d]) {\n      cb(null, addresses[d]);\n      return;\n    }\n\n    lib.getMacAddress(d, cb);\n  };\n\n  util.iterate(args, getMacAddress, callback);\n};\n\nlib.all = function (callback) {\n  if (typeof callback !== \"function\") {\n    return util.promisify(lib.all);\n  }\n\n  var ifaces = lib.networkInterfaces();\n  var resolve = {};\n  Object.keys(ifaces).forEach(function (iface) {\n    if (!ifaces[iface].mac) {\n      resolve[iface] = lib.getMacAddress.bind(null, iface);\n    }\n  });\n\n  if (Object.keys(resolve).length === 0) {\n    if (typeof callback === \"function\") {\n      util.nextTick(callback.bind(null, null, ifaces));\n    }\n\n    return ifaces;\n  }\n\n  util.parallel(resolve, function (err, result) {\n    Object.keys(result).forEach(function (iface) {\n      ifaces[iface].mac = result[iface];\n    });\n\n    if (typeof callback === \"function\") {\n      callback(null, ifaces);\n    }\n  });\n  return null;\n};\n\nmodule.exports = lib;","map":null,"metadata":{},"sourceType":"script"}